---
title: Кэширование
translation: caching/
---

Кэшируя повторно используемые данные, можно предотвратить множество запросов к базе данных, что приведет к повышению производительности. MODX Revolution предлагает ряд различных функций кэширования на разных уровнях в приложении. Кэширование в MODX в основном обрабатывается базовым классом modCacheManager, который расширяет класс xPDOCacheManager и позволяет использовать обработчики кэша, зависящие от раздела. Реализация по умолчанию записывает кэши в файлы в папке core/cache/.

Если вы определили пользовательский ключ MODX_CONFIG_KEY, менеджер кэша выполнит запись в core/cache/MODX_CONFIG_KEY/

## Общая терминология кэширования и поведение

MODX использует разные **разделы** для отдельных типов кэшируемых данных. Упрощенно, раздел - это папка в директории core/cache/, но настоящая ценность разделов в том, что каждому разделу могут быть назначены разные обработчики кэша. **Обработчики кэша** являются производными от класса xPDOCache и предоставляют единый API для хранения, чтения и удаления записей кэша.

Обработчик кэша **по умолчанию** xPDOFileCache записывает кэш в файловую систему в папке core/cache/, но в ядре доступны также другие обработчики кэша для APC (xPDOAPCCache), memcache(d) (xPDOMemCache, xPDOMemCached) и WinCache (xPDOWinCache).

## Разделы основного кэша MODX

В ядре несколько разделов. Их можно легко определить, просмотрев папку core/cache/ с конфигурацией кэша по умолчанию.

Обычно вам не нужно работать с кэшированными данными напрямую (вместо этого используйте доступные API), но для понимания ядра MODX здесь мы рассмотрим основные разделы и кратко опишем их назначение и содержание.

Как мы обсудим позже, пользовательские провайдеры также могут быть использованы в разработке.

- **action_map** содержит большой массив всех действий (идентификаторов, ссылающихся на контроллеры и пространства имен), которые могут быть доступны в менеджере. Поскольку действия устарели и больше не используются в 2.3, никогда не полагайтесь на них.
- **auto_publish** содержит метку времени Unix, которая определяет, когда ресурс должен быть автоматически опубликован или распубликован (см. ModCacheManager.autoPublish())
- **context_settings** для каждого контекста на сайте содержит карту ресурсов (идентификаторы родительских и дочерних документов), карту псевдонимов, используемые в контексте плагины и политики доступа.
- **db** раздел кэша базы данных используется, когда включена системная или контекстная настройка cache_db, и содержит необработанные наборы результатов для запросов xPDO getObject/getCollection. Подробнее об этом ниже.
- **includes** - на самом деле, это не раздел кэша, но он содержит файлы PHP, где фрагменты и плагины заключены в вызовы функций для легкого выполнения ядром. Смотрите сценарии для раздела кэша для фрагментов и плагинов.
- **logs** - это также не раздел кэша, но содержит файл error.log и иногда другие файлы журнала (например, журнал установки).
- **menu** cодержит для каждого языка менеджера многомерный массив верхнего меню менеджера.
- **mgr** не является настоящим разделом кэша, но используется Smarty и Google Minify в 2.2 для записи файлов кэша.
- **registry** - это директория по умолчанию для modRegistry, в которую записываются журналы регистрации файлов. Не является настоящим разделом кэша.
- **resource** содержит организованный по контексту и идентификатору ресурса механизм частичного кэширования ресурсов. Эти файлы кэша содержат метаданные для ресурса, кэшированное представление ресурса (_content) с оставшимися без кэширования тегами, политиками доступа к ресурсу и элементами и их источниками, используемые при обработке ресурса.
- **rss** не является настоящим разделом кэша, но используется MagpieRSS (виджеты RSS панели) для записи в кеш.
- **scripts** содержит источник сниппетов и плагинов, которые впоследствии записываются в папку кэша includes.
- **setup**  не является настоящим разделом кэша, но используется инсталлятором MODX для кэширования шаблонов Smarty.
- **system_settings** содержит глобальную конфигурацию MODX и системные настройки. Этот раздел загружается первым по запросам в MODX. Поскольку альтернативные обработчики кэша для разделов хранятся в системных настройках, этот раздел не может быть загружен из другого обработчика кэша таким образом.

Чтобы изменить обработчик кэша для определенного раздела кэша, просто создайте новый системный (или контекстный) параметр с именем cache_PARTITION_handler (например, cache_resource_handler или cache_scripts_handler) и присвойте ему значение обработчика кэша, который вы хотели бы использовать. По умолчанию используется xPDOFileCache, однако и другие обработчики доступны для APC, memcache (d) и wincache.

Обратите внимание, что в MODX 2.0.x система кэша довольно сильно отличалась. Доступные разделы были иными, а системные настройки сохранялись в core/cache/config.cache.php. Если вы все еще используете MODX 2.0.x, вам следует потратить больше времени на обновление и меньше времени на чтение этого документа.

### Кэширование базы данных

Если вы включите системный параметр **cache_db**, MODX может автоматически кэшировать наборы результатов базы данных, извлеченные любым экземпляром xPDOCriteria или xPDOQuery. Это включает в себя все наборы результатов, представляющие xPDOObjects или коллекции xPDOObjects, возвращаемые такими методами, как getObject и getCollection.

Эта функция может быть включена в средах, где доступ к базе данных обходится дороже, чем время подключения файлов PHP, например, при использовании внешнего сервера базы данных, или настраивается для сред с доступным memcached, APC или другими системами кэширования. Это отдельный раздел кеша в MODX, поэтому его можно настроить с другими обработчиками кэша. Смотрите [xPDO Caching](extending-modx/xpdo/caching) для дополнительной информации.

## Обновление кэша MODX Core

Чтобы обновить любой из основных разделов кэша MODX, используйте метод `modCacheManager->refresh()`. Минимальный вызов не имеет параметров и обновит все разделы основного кэша.

```php
$modx->cacheManager->refresh();
```

Кроме того, вы можете определить массив `$providers` с разделом элементов `key => $partitionOptions`.

```php
// Обновить только настройки контекстов web и web2
$modx->cacheManager->refresh(array('context_settings'=>array('contexts'=> array ('web', 'web2')));
```

Второй параметр `$results` передается по ссылке и будет содержать результаты каждого раздела кэша. В зависимости от раздела это может быть логическое значение или массив с дополнительной информацией о результате обновления определенного раздела. Сама функция возвращает логическое значение, указывающее, вернул ли какой-либо из разделов логическое значение false.

## Программное (пользовательское) кэширование

Взаимодействуя с modCacheManager, вы можете легко кэшировать данные любого типа. Есть несколько полезных функций, которые вы можете использовать для поддержания рабочего кэша. Используя modCacheManager с пользовательским разделом (хотя и необязательно), пользователи вашего кода могут изменить обработчик кэша и сохранить данные в экземпляре memcached, APC или WinCache вместо файлового кэша по умолчанию.

ModCacheManager (производный от xPDOCacheManager) предоставляет следующие полезные методы:

- `add($key, $var, $life = 0, $options = array())` используется для добавления значения в кэш, но только если оно еще не существует или срок его действия истек.
- `replace($key, $var, $life = 0, $options = array())` используется для замены существующего кэшированного значения другим.
- `set($key, $var, $life = 0, $options = array())` используется для установки значения в кэш независимо от того, существует ли оно уже (перезаписывается) или нет (добавляется).
- `delete($key, $options = array())` удаляет кэшированное значение из кэша.
- `get($key, $options = array())` получает кэшированное значение из кэша.
- `clean($options = array())` очищает (удаляет) весь поставщик кэша. Убедитесь, что вы определили xPDO::OPT_CACHE_KEY в массиве параметров.

В общем случае вы можете использовать `get($key)` и `set($key, $value)` для получения и установки значений соответственно, но дополнительные методы обеспечивают дополнительный контроль над способом управления данными.

Массив `$options` может содержать следующие параметры, указывающие раздел кэша для записи, используемый обработчик кэша и время истечения по умолчанию.

- `xPDO::OPT_CACHE_KEY` - раздел кэша для записи.
- `xPDO::OPT_CACHE_HANDLER` - используемый обработчик кэша. Как правило, вам не нужно жестко определять этот параметр, но имеет смысл разрешать конкретной реализации обрабатывать обработчик кэша с помощью системных настроек (то есть системных настроек cache_PARTITION_handler).
- `xPDO::OPT_CACHE_EXPIRES` - время истечения по умолчанию.

### Пример 1: Простое добавление и получение кэша

```php
$str = 'Мои тестовые данные для кэша.';

// Записываем данные в раздел кеша по умолчанию со сроком действия 2 часа. $modx->cacheManager->set('testdata', $str, 7200);

// Получаем данные из кеша снова. Возвращается ноль, если кеш недоступен или срок его действия истек. 
$str = $modx->cacheManager->get('testdata');
```

### Пример 2. Добавление и получение кэша из пользовательского раздела

```php
$str = 'Мои тестовые данные для кэша.';

$options = array(xPDO::OPT_CACHE_KEY=>'mypartition',); 

// Записываем данные в раздел кеша по умолчанию со сроком действия 2 часа. $modx->cacheManager->set('testdata', $str, 7200, $options); 

// Получаем данные из кеша снова. Возвращается ноль, если кеш недоступен или срок его действия истек. 
$str = $modx->cacheManager->get('testdata', $options);
```

## Обратите внимание в Revolution 2.0

В MODX Revolution 2.0 была другая система кеширования с отличающимися разделами. Чтобы очистить кеш в 2.0, вы должны использовать метод clearCache(), который устарел с 2.1. Лучше обновиться до последней версии, чем продолжать использовать 2.0.

```php
// Очищаем всё по умолчанию (все файлы с расширением .cache.php 
// в cachePath + все кэши объектов) 
$modx->cacheManager->clearCache();

// очищаем только файлы кэша с расширением .php или .log в путях web/, custom/ 
// или logs/; объекты не очищаются 
$paths = array('web/', 'custom/', 'logs/');

$options = array('objects'=>null, 'extensions'=> array('. php', '.log'));

$modx->cacheManager->clearCache($paths, $options);

// очищаем все файлы кеша с расширением .php в cachePath 
// + все объекты + выполняем проверки по времени публикации 
$paths = array('');
$options = array('objects'=>'*', 'publishing'=>true, 'extensions'=>array('. php')); 
$modx->cacheManager->clearCache($paths, $options);
```
